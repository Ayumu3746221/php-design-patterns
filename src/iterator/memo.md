# Iteratorパターン まとめ

## 1. Iteratorパターンとは？

**「集合体（コレクション）」と「反復処理（イテレーション）」のロジックを分離する**デザインパターン。

このパターンを使うことで、コレクションの内部構造（配列、木構造、データベースの結果セットなど）を外部に公開することなく、統一的なインターフェース（PHPでは `foreach`）で要素にアクセスできるようになる。

## 2. PHPにおける主な登場人物

- **`Iterator` インターフェース:**
  - 反復処理の振る舞いを定義する。以下の5つのメソッドを持つ。
  - `current()`: 現在の要素を返す。
  - `key()`: 現在のキーを返す。
  - `next()`: 次の要素に進む。
  - `rewind()`: 最初の要素に戻す。
  - `valid()`: 現在位置が有効か調べる（`foreach`のループ継続条件）。

- **`IteratorAggregate` インターフェース:**
  - 「自分自身は反復処理のロジックを持たないが、反復処理を行う`Iterator`オブジェクトを生成できる」ことを示す。
  - `getIterator()` メソッドを一つだけ持つ。
  - `ArrayIterator`など既存のIteratorに処理を委譲できるため、自前で`Iterator`を実装するよりシンプルになることが多い。

## 3. 主な使用場面・メリット

#### a. 巨大なデータセットの効率的な処理（遅延読み込み）

- **概要:**
  - 数百万件のDBレコードや巨大なログファイルなど、一度にメモリに読み込めないデータを扱う際に非常に有効。
  - `Iterator`内でデータを1件ずつ（あるいは一定のチャンクサイズで）読み込む「遅延読み込み（Lazy Loading）」を実装することで、メモリ使用量を小さく一定に保つことができる。
- **使用例:**
  - **バッチ処理:** 全ユーザーへのメール送信、全商品のデータ更新、日次レポート生成など。
  - **データ移行:** 古いDBから新しいDBへのデータ移し替え。
  - **検索エンジンのインデックス作成:** サイト内検索のために、全ドキュメントをスキャンして索引を構築する処理。

#### b. 複雑なデータ構造の単純化

- **概要:**
  - 木構造やグラフなど、単純なループでは走査できない複雑なデータ構造の反復処理ロジックを`Iterator`クラス内にカプセル化する。
  - 利用者側は、データ構造を意識することなく、単純な`foreach`で全要素にアクセスできる。
- **使用例:**
  - **カテゴリの木構造:** 入れ子になったカテゴリを順番に辿る。
  - **ファイルシステムのディレクトリ走査:** 再帰的なディレクトリの探索。
  - **SNSのコメント欄:** 入れ子になったコメントと返信を時系列順に表示する。

#### c. カプセル化と柔軟性の向上

- **概要:**
  - コレクションの内部実装（`array`なのか、連想配列なのか等）を利用者側から隠蔽できる。
  - 将来的にコレクションの内部実装を変更しても、`getIterator()`が返す`Iterator`が同じ振る舞いを保証すれば、利用者側のコード（`foreach`）は一切変更する必要がない。

## 4. 注意すべき点

- **DBでの遅延読み込みと「非バッファリングクエリ」:**
  - PHPのPDOで真の遅延読み込みを実現するには、**非バッファリングクエリ**を有効にする必要がある（`PDO::MYSQL_ATTR_USE_BUFFERED_QUERY => false`）。
  - デフォルトのバッファリングクエリでは、`query()`を実行した時点で結果セット全体がPHPのメモリに読み込まれてしまい、遅延読み込みのメリットが得られない。

- **Webページネーションとの違い:**
  - Webサイトの「次へ」ボタンのようなページネーション機能は、広義の遅延読み込みの一種だが、実装に必ずしも`Iterator`パターンが必要なわけではない。
  - リクエスト毎に`LIMIT`と`OFFSET`を指定してDBにクエリを投げる、より直接的な実装が一般的。

- **過剰な設計を避ける:**
  - 対象のデータが常に小規模な配列であり、将来的に複雑化する見込みがない場合、`Iterator`パターンは過剰な設計になる可能性がある。シンプルなゲッターメソッドで配列全体を返すだけでも十分な場合もある。
